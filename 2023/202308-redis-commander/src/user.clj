(ns user
  "Try using redis streams as the ledger/backbone for a commander architecture.

   - https://www.youtube.com/watch?v=30Odhss1xVA
   - https://www.youtube.com/watch?v=B1-gS0oEtYc
   - https://www.youtube.com/watch?v=qDNPQo9UmJA"
  (:require
   [clojure.test :as t :refer [deftest testing is]]
   [clojure.core.async :as a]
   [clojure.string :as str]
   [integrant.core :as ig]
   [integrant.repl]
   [malli.core :as m]
   [malli.dev.pretty :as pretty]
   [malli.util :as mu]
   [portal]
   [taoensso.carmine :as car :refer [wcar]]
   [taoensso.timbre :as timbre]))

;; DRAMATIS PERSONAE:
;; evt ......... Event, a map
;; cmd ......... Command, a map
;; ci-evt ...... Command Issuance, an event with an issued-command payload
;; ca-evt ...... Command Acceptance, an event with an accepted-command payload
;; cr-evt ...... Command Rejection, an event with a rejected-command payload
;; eid ......... Event ID, a timestamp string in Redis streams
;;               (see https://redis.io/docs/data-types/streams/#entry-ids
;; cid ......... Command ID, a uuid (so that it can be generated by a client)
;; ts .......... Timestamp, an instant

;;
;; schemas
;;

(defn validate! [spec value]
  (when-not (m/validate spec value)
    (pretty/explain spec value)
    (let [data {:reason :user/malli-failure
                :value value
                :spec spec
                :err (m/explain spec value)}]
      (throw (ex-info "malli failure" data)))))

(def schema:evt-name symbol?)

(def schema:cmd-name symbol?)

(def schema:evt
  "Events are records of effects that have happened in the system, for
   secondary reactions (eg. updating the UI) or updating derived data
   (eg. the audit log on a project).

   The only kind of event that can lead to a system mutation is a
   `:command/issued` event. (Note the lower case and passive voice).

   Possible uses for metadata:
   - including a set of audience user-ids to let downstream
   processes know how to distribute messages;
   - ..."
  (let [user-id string?]
    [:map {:closed true}
     [:evt/name      schema:evt-name]
     [:evt/author-id user-id]
     [:evt/data      :map]
     [:evt/metadata  {:optional true} :map]
     ;; id, parent-id, ts optional b/c needs id from redis
     [:evt/parent-id {:optional true} :string]
     [:evt/id        {:optional true} :string]
     [:evt/ts        {:optional true} inst?]]))

(def schema:cmd
  "Commands are expressions of a user's intent, as data.

   They are observable in the event ledger as (issued, accepted) or
   (issued, rejected) pairs of events. (On the front-end, we might see a
   transient (issued, bounced) pair, signifying something didn't even make
   it into the ledger usually for authz reasons).

   They flow into the ledger, where the fact of a command is quickly persisted
   as an event. A command/issued event wrapping the command flows into the
   commander, where it's acted on, and will lead to either an accepted event or
   a rejected event (plus some optional other side events that happened. Note
   that the commander issuing a command in response is also a kind of side
   event :mindblown:).

   Commands are named with all-caps imperative voice, like :DO-A-THING!"
  [:map {:closed true}
   [:cmd/id   uuid?]
   [:cmd/name schema:cmd-name]
   [:cmd/data {:optional true} :map]])

(def schema:issued-cmd
  "Regardless of whether a command is ultimately accepted or rejected,
   processing is kicked off by recording the fact that it was issued (which is
   always true)."
  (mu/merge schema:evt
            [:map
             [:evt/name [:= 'command/issued]]
             [:evt/data schema:cmd]]))

(defn get-cmd-name [evt] (get-in evt [:evt/data :cmd/name]))

(defn get-cmd-id [evt] (get-in evt [:evt/data :cmd/id]))

(defn make-cmd-issuance-evt
  ([author-id cmd-name] (make-cmd-issuance-evt author-id cmd-name {}))
  ([author-id cmd-name data]
   #:evt{:name 'command/issued
         :author-id author-id
         :data #:cmd {:id (random-uuid)
                      :name cmd-name
                      :data data}}))

(defn make-child-evt
  [author-id evt child-evt-name data]
  #:evt{:name      child-evt-name
        :author-id author-id
        :parent-id (:evt/id evt)
        :data      data})

(defn make-cmd-rejection-evt
  [author-id evt reason data]
  (make-child-evt author-id evt 'command/rejected
                  (merge data
                         {:rejection/reason reason
                          :cmd/id (get-cmd-id evt)
                          :cmd/name (get-cmd-name evt)})))

(defn make-cmd-acceptance-evt
  [author-id evt data]
  (make-child-evt author-id evt 'command/accepted
                  (merge data
                         {:cmd/id (get-cmd-id evt)
                          :cmd/name (get-cmd-name evt)})))

(defn matches-evt?
  "Make a predicate f :: evt -> Bool returning true when an evt is in the
   provided set of events."
  [evts]
  (let [pred (set evts)]
    (validate! [:set schema:evt-name] pred)
    (comp pred :evt/name)))

(defn cmd-evt?
  [evt]
  ((matches-evt? '#{command/issued command/accepted command/rejected}) evt))

;;
;; ledger
;;

(defn redis-entry-id->ts [entry-id]
  (let [ms (first (str/split entry-id #"-"))]
    (java.time.Instant/ofEpochMilli (parse-long ms))))

(defn redis-entry->evt [re]
  (let [[eid [_ evt]] re]
    (assoc evt :evt/id eid :evt/ts (redis-entry-id->ts eid))))

(defn get-all-evts
  ;; nb. redis stream ids are timestamps, just derived from redis entry id
  ;; so extract an inst to get a ts; we don't need to record this separately
  ([ledger] (get-all-evts ledger "-"))
  ([ledger first-eid]
   (->> (wcar (:redis ledger)
              (car/xrange (:stream ledger) first-eid "+"))
        (map redis-entry->evt))))

(defprotocol ILedger
  (start-delivering! [this] [this last-eid]
    "Start the ledger distributing new events")
  (stop-delivering! [this]
    "Stop the ledger from distributing new events")
  (delivering? [this]
    "Is the ledger delivering events?")
  (record-event [this evts]
    "Add an event to the ledger for distribution.")
  (listen-for-events [this chan]
    "Connect chan to the ledger for delivery of new events.")
  (stop-listening-for-events [this chan]
    "Disconnect chan from the ledger.")
  (trim-events [this eid]
    "Trim old events before eid."))

(defn read-events
  "Read events from a Redis stream.

   The call will block until the end of timeout, and will:
   - succeed with valid events;
   - return nil if no event arrived during the timeout; or
   - throw if the event that was pulled from the stream was not valid.

   Pass 0 for timeout to wait forever. Pass $ for last-eid to get the 'next'
   event."
  [redis stream batch-size timeout-ms last-eid]
  (when-let [redis-entries (wcar redis (car/xread
                                        "COUNT" batch-size
                                        "BLOCK" timeout-ms
                                        "STREAMS" stream
                                        last-eid))]
    (let [evts (->> redis-entries first second (map redis-entry->evt))]
      (doseq [evt evts] (validate! schema:evt evt))
      evts)))

(defrecord RedisLedger [redis stream pub-chan mult-chan *state]
  ;; conceal redis's presence behind a facade ... the ledger's job is only to
  ;; persist events and then pass them on, not to act on them
  ;; pass in a configured channel; the delivery loop will throw events onto it
  ;; as they occur
  ILedger
  (start-delivering! [this]
    (start-delivering! this "$")) ;; "$" in redis is "last event"
  (start-delivering! [_ last-eid]
    (timbre/debug "starting delivery loop")
    (swap! *state assoc :delivering? true)
    ;; block on redis reads on a separate thread and ship events off on the
    ;; channel when they arrive
    (a/thread
      (loop [last-eid last-eid]
        (if (:delivering? @*state)
          (do (timbre/debug "ledger waiting for event")
              (let [batch-size 1
                    timeout-ms 0 ;; wait "forever"
                    evts (read-events redis stream batch-size timeout-ms
                                      last-eid)]
                (timbre/debug "delivering event")
                (doseq [evt evts] (a/>!! pub-chan evt))
                (recur (-> evts last :evt/id))))
         ;; there's a bug here:
         ;; if we stop delivery and no event comes in to flush out the queue,
         ;; we'll have 2 loops running
          (do (timbre/debug "stopping delivery loop")
              (swap! *state assoc :delivering? false)
              :done))))
    :started)

  (stop-delivering! [_]
    ;; nb. will keep delivering til the last XREAD timeout expires with nil or
    ;; possibly one last event
    (timbre/debug "marking delivery loop as stopped")
    (swap! *state assoc :delivering? false)
    :stopped)

  (delivering? [_]
    (boolean (:delivering? @*state)))

  (record-event [_ evt]
    (timbre/debug "pushing evt to redis")
    (validate! schema:evt evt)
    (wcar redis (car/xadd stream
                          ; "MAXLEN" "~" 10000 ;; uncomment to cap stream size
                          "*"
                          "evt"
                          ;; lose any provided timestamp since redis stream ids
                          ;; will be the source of truth here
                          (dissoc evt :evt/ts))))

  (listen-for-events [_ chan]
    ;; audience fan-out using mult/tap
    ;; nb. the provided chan can slow down the mult; make sure they're buffered
    ;; correctly. Provide transducers on the channels to filter for specific
    ;; events.
    ;; (...hm, should ledger be the one that maintains the state of its
    ;; consumers for trimming? Or should consumers have to ACK someplace else?)
    (timbre/debug "connecting" chan "to ledger mult")
    (a/tap mult-chan chan)
    chan)

  (stop-listening-for-events [_ chan]
    (timbre/debug "disconnecting" chan "from ledger mult")
    (a/untap mult-chan chan)
    chan)

  (trim-events [_ eid]
    ;; car/xtrim seems to have trouble rn, so use redis-call
    ;; https://github.com/taoensso/carmine/issues/283
    (wcar redis (car/redis-call [:xtrim stream "MINID" "~" eid]))))

;;
;; integrant
;;

(def system-config
  {#_#_:user/portal    {}
   :user/state     {:counter 0}
   :user/redis     {:uri "redis://localhost:6379/2"}
   :user/ledger    {:redis (ig/ref :user/redis)
                    :stream "myledger"}
   :user/commander {:ledger (ig/ref :user/ledger)
                    *system-state (ig/ref :user/state)}
   :user/fizzbuzz  {:ledger (ig/ref :user/ledger)}
   #_#_:user/archiver {:ledger (ig/ref :user/ledger)
                       *system-state (ig/ref :user/state)}})

;; "state" component
;; system state would usually be a postgres db or such; just an atom here
;; for illustration

(defmethod ig/init-key :user/state
  [_ {:keys [counter]}]
  (atom {:counter counter
         ;; last event-ids processed
         ;; (in practice these should be persisted someplace. Here we'll
         ;; restart the commander from earliest message every time the system
         ;; starts up).
         :last-eids {:user/commander 0
                     :user/consumer-1-fizzbuzz 0
                     :user/consumer-2-archiver 0}}))

(defmethod ig/init-key :user/portal [_ _] (portal/start-portal))
(defmethod ig/halt-key! :user/portal [_ _] (portal/stop-portal))

;; redis component

(defmethod ig/init-key :user/redis
  [_ {:keys [uri]}]
  (let [opts {:pool (car/connection-pool {}) :spec {:uri uri}}]
    (when-not (= "PONG" (wcar opts (car/ping)))
      (throw (ex-info "can't communicate with redis" opts)))
    opts))

;; ledger component

(defmethod ig/init-key :user/ledger
  [_ {:keys [stream redis]}]
  ;; a sliding buffer is arguably what we want: at a certain point we're
  ;; interested in novelty and if downstream can't keep up we sacrifice the old
  ;; events
  (let [pub-chan (a/chan (a/sliding-buffer 256))
        ledger (map->RedisLedger {:redis redis
                                  :stream stream
                                  :pub-chan pub-chan
                                  :mult-chan (a/mult pub-chan)
                                  :*state (atom {})})]
    (start-delivering! ledger)
    ledger))

(defmethod ig/halt-key! :user/ledger
  [_ this]
  (a/close! (:chan this))
  (stop-delivering! this))

;; commander component

(defmulti transact!
  "Mutate system state in response to an issued command."
  (fn [_author-id _*state evt] (tap> evt) (get-cmd-name evt)))

(defmethod transact! :default
  [author-id _ evt]
  ;; Default action is to reject the command and not change system state.
  ;;
  ;; We allow-list new commands by implementing new multimethods. This lets us
  ;; put the method bodies closer to the code for the specific domain.
  [(make-cmd-rejection-evt author-id evt "no-handler-for-cmd" {})])

(defn process-command! [*state evt]
  (timbre/debug "transacting command" (get-cmd-name evt))
  (try
    (let [evts (transact! "commander" *state evt)]
      (if (m/validate [:sequential schema:evt] evts)
        evts
        (throw (ex-info "didn't get events from transact!"
                        {:return-value evts}))))
    ;; handle normal command processing rejection using exception control flow
    ;; so that we make sure the commander loop is airtight and we don't have
    ;; loop death
    (catch Exception ex
      [(make-cmd-rejection-evt "commander"
                               evt
                               (ex-message ex)
                               {:rejection/data (ex-data ex)})])))

(defn summarize-cmds
  "Reduce cmds sharing an id into a summary view"
  [cmd-evts]
  (let [rfn (fn [acc evt]
              {:cmd/id (get-cmd-id evt)
               :cmd/name (get-cmd-name evt)
               :cmd/verdict (case (:evt/name evt)
                              command/rejected :verdict/rejected
                              command/accepted :verdict/accepted
                              :verdict/unresolved)
               :evt/ids ((fnil conj [])
                         (:evt/ids acc)
                         (:evt/id evt))
               :evt/author-ids ((fnil conj [])
                                (:evt/author-ids acc)
                                (:evt/author-id evt))
               :evt/tss ((fnil conj [])
                         (:evt/tss acc)
                         (:evt/ts evt))})
        m (->> cmd-evts
               (sort-by :evt/ts)
               (reduce rfn {}))]
    (-> m
        (assoc :evt/started-at (first (:evt/tss m)))
        (assoc :evt/processing-ms
               (if (not= 1 (count (:evt/tss m)))
                 (apply - (reverse (map #(.toEpochMilli %) (:evt/tss m))))
                 0))
        (dissoc :evt/tss))))

(defn list-commands
  "Pluck command event pairs out of event stream."
  ([ledger] (list-commands ledger "-"))
  ([ledger first-eid]
   (->> (get-all-evts ledger first-eid)
        (filter cmd-evt?)
        (group-by get-cmd-id)
        (vals)
        (map summarize-cmds)
        (sort-by :evt/started-at))))

(defmethod ig/init-key :user/commander
  ;; the commander's job is to act on command-issued events
  ;; it provides a channel for the ledger to stuff new events into
  ;; we use a filter on the channel to pay attention to only issued commands
  [_ {:keys [*system-state ledger]}]
  (timbre/info "starting commander component")
  (let [xf (filter (matches-evt? #{'command/issued}))
        chan (a/chan 1 xf)
        _ (listen-for-events ledger chan)
        worker (a/go-loop []
                 (when-some [evt (a/<! chan)]
                   (doseq [evt (process-command! *system-state evt)]
                     (record-event ledger evt))
                   (recur)))]

    {:chan chan :worker worker :ledger ledger}))

(defmethod ig/halt-key! :user/commander
  [_ this]
  ; (stop-listening-for-events (:ledger this) (:chan this))
  (a/close! (:chan this)))

;; first example consumer component
;; eg. a logger that fires when the counter achieves fizzbuzz

(t/with-test

  (defn fizz-buzz [n]
    (cond
      (zero? n)               nil
      (zero? (rem n (* 3 5))) "FizzBuzz"
      (zero? (rem n 3))       "Fizz"
      (zero? (rem n 5))       "Buzz"))

  (is (nil? (fizz-buzz 0)))
  (is (= "Fizz" (fizz-buzz 3)))
  (is (nil? (fizz-buzz 4)))
  (is (= "Buzz" (fizz-buzz 5)))
  (is (= "Fizz" (fizz-buzz 6)))
  (is (= "FizzBuzz" (fizz-buzz 15)))
  (is (= "Buzz" (fizz-buzz 20)))
  (is (= "FizzBuzz" (fizz-buzz 30))))

(defmethod ig/init-key :user/fizzbuzz
  [_ {:keys [ledger]}]
  (timbre/info "starting fizzbuzz component")
  ;; a consumer could also rely on overall system state but to keep it simple
  ;; here it's just an internal counter. Thus, we won't emit fizzbuzz in sync
  ;; with the global counter.
  (let [chan (a/chan (a/dropping-buffer 8)
                     (filter (matches-evt? #{'counter/incremented})))
        worker (a/go-loop [n 0]
                 (when-let [fb (fizz-buzz n)] (timbre/error fb))
                 (when-some [_evt (a/<! chan)] (recur (inc n))))]
    (listen-for-events ledger chan)
    {:chan chan :worker worker}))

(defmethod ig/halt-key! :user/fizzbuzz
  [_ {:keys [chan worker]}]
  (a/close! worker)
  (a/close! chan))

;; second example consumer component
;; eg. a process that persists old events someplace else and trims the old
;; event stream so it doesn't grow without bound in redis. Other consuming
;; processes would have to ACK the last eid they successfully cared about into
;; persistent storage somewhere.

#_(defmethod ig/init-key :user/archiver
    [_ {:keys [ledger *state]}]
    (let [chan (a/chan (a/dropping-buffer 8)
                       (filter (constantly true)))]
      (listen-for-events ledger chan)))

(defn go []
  (integrant.repl/set-prep! #(ig/prep system-config))
  (integrant.repl/go))

;;
;; Example of the specific domain of an incrementing counter
;;

(defmethod transact! 'INCREMENT-COUNTER!
  [author-id *state evt]
  (timbre/debug "processing 'INCREMENT-COUNTER!")

  ;; 1. Actually execute the system mutation if it's valid.
  ;;
  ;; the core `transact!` method for a given command is, in most of cases, the
  ;; place where we finally know enough to know whether the system mutation
  ;; should be permitted. There may be earlier guards, but this is the moment
  ;; of final decision.
  ;;
  ;; It might involve authz, whether the database is in some state, whether
  ;; it's Tuesday, etc. etc. The rest is reusable plumbing that should plod
  ;; through no matter what.

  (let [user (:evt/author-id evt)
        authzd? (= "authorized-user" user)]

    (when-not authzd? (throw (ex-info "not authorized" {:user user})))
    (swap! *state update :counter inc))

  ;; 2. Return for recording in the ledger:
  ;;
  ;;   a. an evt recording that the counter incremented
  ;;   b. an evt recording that the cmd was accepted by the cmdr

  [(make-child-evt author-id evt 'counter/incremented {})
   (make-cmd-acceptance-evt author-id evt {})])

(defn increment-counter!
  "Issue a command to increment the counter."
  [ledger author-id]
  (let [evt (make-cmd-issuance-evt author-id
                                   'INCREMENT-COUNTER!
                                   {})]
    (record-event ledger evt)))
