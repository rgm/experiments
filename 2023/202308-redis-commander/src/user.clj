(ns user
  "Try using redis streams as the ledger/backbone for a commander architecture."
  (:require
   [clojure.string :as str]
   [clojure.core.async :as a :refer [<! >! <!! >!!]]
   [malli.core :as m]
   [integrant.core :as ig]
   [integrant.repl :refer [halt reset]]
   [taoensso.carmine :as car :refer [wcar]]))

;; DRAMATIS PERSONAE:
;; evt ......... Event, a map
;; cmd ......... Command, a map
;; ci-evt ...... Command Issuance, an event with an issued-command payload
;; ca-evt ...... Command Acceptance, an event with an accepted-command payload
;; cr-evt ...... Command Rejection, an event with a rejected-command payload
;; eid ......... Event ID, a timestamp string in Redis streams
;;               (see https://redis.io/docs/data-types/streams/#entry-ids
;; cid ......... Command ID, a uuid (so that it can be generated by a client)
;; ts .......... Timestamp, an instant

;;
;; schemas
;;

(defn validate! [spec value]
  (print value)
  (when-not (m/validate spec value)
    (let [data {:value value :spec spec :err (m/explain spec value)}]
      (throw (ex-info "my invalid value" data)))))

(def schema:evt-name symbol?)

(def schema:cmd-name symbol?)

(def schema:evt
  "Events are records of effects that have happened in the system, for
   secondary reactions (eg. updating the UI) or updating derived data
   (eg. the audit log on a project).

   The only kind of event that can lead to a system mutation is a
   `:command/issued` event. (Note the lower case and passive voice).

   Possible uses for metadata:
   - including a set of audience user-ids to let downstream
   processes know how to distribute messages;
   - ..."
  (let [user-id string?]
    [:map {:closed true}
     [:evt/name      schema:evt-name]
     [:evt/author-id user-id]
     [:evt/data      :map]
     [:evt/metadata  {:optional true} :map]
     ;; id, parent-id, ts optional b/c needs id from redis
     [:evt/parent-id {:optional true} :string]
     [:evt/id        {:optional true} :string]
     [:evt/ts        {:optional true} inst?]]))

(def schema:cmd
  "Commands are expressions of a user's intent, as data.

   They are observable in the event ledger as (submitted, accepted) or
   (submitted, rejected) pairs of events. (On the front-end, we might see a
   transient (submitted, bounced) pair, signifying something didn't even make
   it into the ledger usually for authz reasons).

   They flow into the ledger, where the fact of a command is quickly persisted
   as an event. A command/submitted event wrapping the command flows into the
   commander, where it's acted on, and will lead to either an accepted event or
   a rejected event (plus some optional other side events that happened. Note
   that the commander issuing a command in response is also a kind of side
   event :mindblown:).

   Commands are named with all-caps imperative voice, like :DO-A-THING!"
  (let [user-id string?]
    [:map {:closed true}
     [:cmd/id     uuid?]
     [:cmd/name   schema:cmd-name]
     [:cmd/author user-id]
     [:cmd/data   [:maybe :map]]]))

(def schema:issued-cmd
  "Regardless of whether a command is ultimately accepted or rejected,
   processing is kicked off by recording the fact that it was issued (which is
   always true).
   "
  [:and
   schema:evt
   [:evt/name 'command/issued]
   [:evt/data schema:cmd]])

;;
;; event-filtering predicates
;; an event observer

(defn for-audience? [user-id]
  (fn [evt] (= user-id (get-in evt [:evt/metadata :audience-id]))))

;;
;; ledger
;;

(defn redis-entry-id->ts [entry-id]
  (let [ms (first (str/split entry-id #"-"))]
    (java.time.Instant/ofEpochMilli (parse-long ms))))

(defn get-all-evts [ledger]
  ;; nb. redis stream ids are timestamps, just derived from redis entry id
  ;; so extract an inst to get a ts; we don't need to record this separately
  (->> (wcar (:redis ledger) (car/xrange (:stream ledger) "-" "+"))
       (map (fn [[redis-event-id [_ m]]]
              (assoc m
                     :evt/id redis-event-id
                     :evt/ts (redis-entry-id->ts redis-event-id))))))

(defprotocol ILedger
  (push-event [this evts]
    "Add an event to the ledger.")
  (listen-for-events [this chan]
    "Listen for new events on chan.")
  (stop-listening-for-events [this chan]
    "Stop listening for new events on chan.")
  (trim-events [this eid]
    "Trim old events before eid."))

(defrecord RedisLedger [redis stream pub-chan]
  ;; conceal redis's presence behind a facade
  ;; the ledger's job is to persist events and pass them on
  ;; persistence is a bit fake here since clients push directly to redis behind
  ;; the abstraction of a "ledger" object ... we could buffer with a chan but w/e
  ILedger
  (push-event [_ evt]
    (validate! schema:evt evt)
    (wcar redis (car/xadd stream "*" "evt" evt)))

  (listen-for-events [_ chan]
    ;; audience fan-out ... what about making channels that have a filter on
    ;; them and returning that? ... maybe best handled by consumer since
    ;; it can configure the channel with whatever transducers it feels like adding
    )

  (stop-listening-for-events [_ chan])

  (trim-events [_ eid]
    ;; do XTRIM stuff
    ))

;;
;; integrant
;;

(def system-config
  {::state               {}
   ::redis               {:uri "redis://localhost:6379/2"}
   ::ledger              {:redis (ig/ref ::redis) :stream "myledger"}
   ::commander           {:ledger (ig/ref ::ledger) :*state (ig/ref ::state)}
   ::consumer-1-fizzbuzz {:ledger (ig/ref ::ledger) :*state (ig/ref ::state)}
   ::consumer-2-archiver {:ledger (ig/ref ::ledger) :*state (ig/ref ::state)}
   })

;; "state" component
;; system state would usually be a postgres db or such; just an atom here
;; for illustration

(defmethod ig/init-key ::state
  [_ _]
  (atom {:counter 0
         ;; last event-ids processed
         ;; (in practice these should be persisted someplace. Here we'll
         ;; restart the commander from earliest message every time the system
         ;; starts up).
         :last-eids {::commander 0
                     ::consumer-1-fizzbuzz 0
                     ::consumer-2-archiver 0}}))

;; redis component

(defmethod ig/init-key ::redis
  [_ {:keys [uri]}]
  (let [opts {:pool (car/connection-pool {}) :spec {:uri uri}}]
    (when-not (= "PONG" (wcar opts (car/ping)))
      (throw (ex-info "can't communicate with redis" opts)))
    opts))

;; ledger component

(defmethod ig/init-key ::ledger
  [_ {:keys [stream redis]}]
  (let [pub-chan (a/chan 8)]
    (->RedisLedger redis stream pub-chan)))

(defmethod ig/halt-key! ::ledger
  [_ this]
  (a/close! (:pub-chan this)))

;; commander component

(defn get-cmd-name [evt]
  (validate! schema:issued-cmd evt)
  (get-in evt [:evt/id :cmd-name]))

(defmulti transact!
  "Mutate system state in response to an issued command."
  (fn [_*state evt] (get-cmd-name evt)))

(defmethod transact! :default
  [_ evt]
  ;; Default action is to reject the command and not change system state. We
  ;; allow-list new commands by implementing new multimethods. This lets us put
  ;; the method bodies closer to the other code for the specific domain.
  (let [parent-id (:evt/id evt)
        cmd-name (get-cmd-name evt)]
    #:evt{:name 'command/rejected
          :parent-id parent-id
          :data {:cmd/name cmd-name
                 :reason "no handler for cmd"}}))

(defn matches-evt?
  [evts]
  (let [pred (set evts)]
    (validate! [:set schema:evt-name] pred)
    pred))

(defmethod ig/init-key ::commander
  ;; the commander's job is to act on command-submitted events
  ;; it provides a channel for the ledger to stuff new events into
  ;; we use a filter on the channel to pay attention to only issued commands
  [_ {:keys [*state ledger]}]
  (let [chan (a/chan 8 #_(filter))]
    (a/go
     (loop []
       (when-some [evt (a/<! chan)]
         ;; we know it's a command/issued because we filtered the chan
         (try (transact! *state evt)
           (catch Exception ex
             (let [{parent-id :evt/id
                    author-id :evt/author-id} evt
                   cmd-name (get-cmd-name evt)]
               (push-event ledger #:evt{:author-id author-id
                                        :parent-id parent-id
                                        :name 'command/rejected
                                        :data {:cmd/name cmd-name
                                               :reason (ex-message ex)}}))))
         (recur)))
     (print "closing commander chan"))
    (listen-for-events ledger chan)
    {:chan chan :ledger ledger}))

(defmethod ig/halt-key! ::commander
  [_ this]
  (stop-listening-for-events (:ledger this) (:chan this))
  (a/close! (:chan this)))

;; example consumer component
;; eg a logger that fires when the counter achieves fizzbuzz

(defmethod ig/init-key ::consumer-1-fizzbuzz
  [_ {:keys [ledger *state]}]
  (let [chan (a/chan (a/dropping-buffer 8)
                     (filter (constantly true)))]
    (listen-for-events ledger chan)))

;; example consumer component
;; eg a process that persists old events someplace else and trims the old event
;; stream so it doesn't grow without bound in redis

(defmethod ig/init-key ::consumer-2-archiver
  [_ {:keys [ledger *state]}]
  (let [chan (a/chan (a/dropping-buffer 8)
                     (filter (constantly true)))]
    (listen-for-events ledger chan)))

(defn go []
  (integrant.repl/set-prep! #(ig/prep system-config))
  (integrant.repl/go))

;;
;; Example of the specific domain of an incrementing counter
;;

(defmethod transact! 'INCREMENT-COUNTER!
  [*state evt]
  (let [parent-id (:evt/id evt)
        cmd-name (get-cmd-name evt)
        authzd? (= (:evt/author-id evt) "authorized-author")]
    ;; increment the counter here if authzd
    (when-not authzd?
      (throw (ex-info "not authorized" {:evt/author-id (:evt/author-id evt)
                                        :evt/id parent-id
                                        :cmd/name cmd-name})))
    (swap! *state :counter inc)
    #:evt{:name      'command/accepted
          :parent-id parent-id
          :data      {:cmd/name cmd-name}}))

(defn increment-counter!
  "Issue a command to increment the counter."
  [ledger author-id]
  (push-event ledger
              #:evt{:name 'command/submitted
                    :data #:cmd{:name 'INCREMENT-COUNTER!
                                :author author-id
                                :data {}}}))

(comment
  (try (go) (catch Exception ex (print (ex-data ex))))
  (halt)
  (try (reset) (catch Exception ex (prn (ex-data ex))))
  (do
    (require '[integrant.repl.state :as irs])
    (def redis (::redis irs/system))
    (def ledger (::ledger irs/system))
    (def commander (::commander irs/system)))
  (a/>!! (-> commander :chan) "test")
  (a/close! (:chan commander))
  (increment-counter! ledger "authorized-author")
  (increment-counter! ledger "unauthorized-author")
  (get-all-evts ledger)
  (def stream (:stream ledger))
  (wcar redis (car/xadd stream "*" "x" {:foo "bar"}))
  (wcar redis (car/xread "count" 2 "streams" stream 0))
  (wcar redis (car/xread "block" 300 "streams" stream "$"))
  (wcar redis (car/xdel stream "1692989244519-0"))
  (wcar redis (car/xtrim stream "MAXLEN" 0)))

;; todo
;; - figure out validation
;; - get ledger pulling events, need a/alts
;; - get command acceptance working
;; - get command rejection working
;; - xtrim and max queue length
