{"version":3,"sources":["helix/impl/props.cljc"],"mappings":"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","names":["helix.impl.props/aria-data-special-case-re","helix.impl.props/camel-regexp","js/RegExp","helix.impl.props/camel-case","s","cljs.core/Keyword","cljs.core/Symbol","name-str","cljs.core/name","cljs.core._EQ_","p1__27347#","p2__27346#","helix.impl.props/kw->str","kw","kw-ns","cljs.core/namespace","kw-name","helix.impl.props/set-obj","o","k","v","G__27348","goog.object/set","helix.impl.props/->js","x","cljs.core.clj__GT_js","cljs.core.comp","var_args","G__27350","helix.impl.props/primitive-obj","js/Error","m","helix.impl.props.primitive_obj","cljs.core/seq","cljs.core/rest","entry","cljs.core/first","cljs.core/key","cljs.core/val","helix.impl.props/into-js-array","aseq","cljs.core.into_array","helix.impl.props/merge-obj","o1","o2","G__27363","goog.object/extend","helix.impl.props/seq-to-class","class","cljs.core.remove","cljs.core/nil?","cljs.core.map","cljs.core/str","clojure.string.join","helix.impl.props/normalize-class","cljs.core/sequential?","helix.impl.props/or-undefined","js/undefined","helix.impl.props/native-style","style","cljs.core/vector?","cljs.core/map?","G__27365","helix.impl.props/-native-props","helix.impl.props._native_props","G__27366","G__27369","helix.impl.props/-props","helix.impl.props._props"],"sourcesContent":["(ns helix.impl.props\n  (:require [clojure.string :as string]\n            #?@(:cljs [[cljs-bean.core :as b]\n                       [goog.object :as gobj]]))\n  #?(:cljs (:require-macros [helix.impl.props])))\n\n(def aria-data-special-case-re #\"^(aria-|data-).*\")\n\n#?(:cljs (def camel-regexp (js/RegExp \"-(\\\\w)\", \"g\")))\n\n(defn camel-case\n  \"Returns camel case version of the string, e.g. \\\"http-equiv\\\" becomes \\\"httpEquiv\\\".\"\n  [s]\n  (if (or (keyword? s)\n          (string? s)\n          (symbol? s))\n    (let [name-str (name s)]\n      ; this is hot path so we want to use low-level interop\n      #?(:clj  (cond\n                 (some? (re-matches aria-data-special-case-re name-str)) name-str\n                 (= (subs name-str 0 1) \"'\") (subs name-str 1)\n                 :else (string/replace name-str #\"-(\\w)\" #(string/upper-case (second %))))\n         :cljs (cond\n                 (some? (.match name-str aria-data-special-case-re)) name-str\n                 (= (.substring name-str 0 1) \"'\") (.substring name-str 1)\n                 :else (.replace name-str camel-regexp #(.toUpperCase %2)))))\n      s))\n\n(comment\n  (camel-case \"get-asdf-aw9e8f\"))\n\n(defn kw->str [kw]\n  (let [kw-ns (namespace kw)\n        kw-name (name kw)]\n    (if (nil? kw-ns)\n      kw-name\n      (str kw-ns \"/\" kw-name))))\n\n\n(defn set-obj [o k v]\n  #?(:clj (conj o k v)\n     :cljs (doto o (gobj/set k v))))\n\n#?(:cljs (defn ->js [x]\n           (clj->js x :keyword-fn (comp camel-case name))))\n\n(defn primitive-obj\n  ([] #?(:clj '[cljs.core/js-obj]\n         :cljs #js {}))\n  ([m]\n   #?(:clj (if (map? m)\n             (primitive-obj m (primitive-obj))\n             ;; fall back to runtime\n             `(primitive-obj ~m))\n      :cljs (primitive-obj m (primitive-obj))))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)]\n              (set-obj o\n                       (camel-case (kw->str (key entry)))\n                       #?(:clj `(->js ~(val entry))\n                          :cljs (->js (val entry))))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n(defn into-js-array [aseq]\n  #?(:clj (list* (into '[cljs.core/array] aseq))\n     :cljs (into-array aseq)))\n\n#?(:cljs\n   (defn merge-obj [o1 o2]\n     (if (nil? o2)\n       o1\n       (doto o1\n         (gobj/extend o2)))))\n\n(defn seq-to-class [class]\n  (->> class\n       (remove nil?)\n       (map str)\n       (string/join \" \")))\n\n#?(:clj\n   (defn unquote-class\n     \"Handle the case of (quote '[foo bar])\"\n     [class]\n     (if (sequential? class)\n       (seq-to-class class)\n       (str class))))\n\n#?(:clj\n   (defn normalize-class [class]\n     (cond\n       (string? class)\n       class\n\n       (and (list? class)\n            (= (first class) 'quote))\n       (unquote-class (second class))\n\n       :default\n       `(normalize-class ~class))))\n\n#?(:cljs\n   (defn normalize-class [class]\n     (cond\n       ;; quick path\n       (string? class) class\n\n       (sequential? class) (seq-to-class class)\n\n       ;; not a string or sequential, stringify it\n       true (str class))))\n\n\n#?(:cljs\n   (defn or-undefined\n     [v]\n     (if (nil? v)\n       js/undefined\n       v)))\n\n\n(defn native-style\n  [style]\n  (cond\n    ;; React Native allows arrays of styles\n    (vector? style) (into-js-array (map primitive-obj style))\n    ;; when map, convert to an object w/ camel casing\n    (map? style) (primitive-obj style)\n    ;; if anything else, at compile time fall back to runtime\n    ;; at runtime just pass it through and assume it's a JS style obj!\n    true #?(:clj `(native-style ~style)\n            :cljs style)))\n\n\n(defn -native-props\n  ([m] #?(:clj (if-let [spread-sym (cond\n                                     (contains? m '&) '&\n                                     (contains? m :&) :&)]\n                 `(merge-obj ~(-native-props (dissoc m spread-sym) (primitive-obj))\n                             (-native-props ~(get m spread-sym)))\n                 (-native-props m (primitive-obj)))\n          :cljs (if (map? m)\n                  (-native-props m (primitive-obj))\n                  ;; assume JS obj\n                  m)))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)\n                  k (key entry)\n                  v (val entry)]\n              (case k\n                :class (set-obj o \"className\" (normalize-class v))\n                :for (set-obj o \"htmlFor\" v)\n                :style (set-obj o \"style\" (native-style v))\n                :value (set-obj o \"value\" #?(:clj `(or-undefined ~v)\n                                             :cljs (or-undefined v)))\n                (set-obj o (camel-case (kw->str k)) v))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n\n(comment\n  (-native-props {:asdf \"jkl\" :style 'foo})\n  )\n\n(defmacro native-props [m]\n  (-native-props m))\n\n\n(defn -props\n  ([m] #?(:clj (if-let [spread-sym (cond\n                                     (contains? m '&) '&\n                                     (contains? m :&) :&)]\n                 `(merge-obj ~(-props (dissoc m spread-sym) (primitive-obj))\n                             (-props ~(get m spread-sym)))\n                 (-props m (primitive-obj)))\n          :cljs (if (map? m)\n                  (-props m (primitive-obj))\n                  m)))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)]\n              (set-obj o (kw->str (key entry)) (val entry))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n(comment\n  (-props {:foo-bar \"baz\"})\n  )\n\n(defmacro props [m]\n  (-props m))\n"]}